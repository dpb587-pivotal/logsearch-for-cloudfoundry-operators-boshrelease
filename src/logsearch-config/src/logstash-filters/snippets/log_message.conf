if [syslog_program] == "doppler" and [@message] =~ /\"event_type\"\:\"LogMessage\"/ {
  json {
    source => "@message"
    target => "LogMessage"
    remove_field => ["@message"]
  }

  mutate {
    rename => { "syslog_program" => "[@source][program]" }
    rename => { "syslog_hostname" => "[@source][host]" }
    rename => { "[LogMessage][source_instance]" => "[@source][index]" }
    rename => { "[LogMessage][cf_app_id]" => "[cf][app_id]" }
    rename => { "[LogMessage][cf_app_name]" => "[cf][app_name]" }
    rename => { "[LogMessage][cf_org_id]" => "[cf][org_id]" }
    rename => { "[LogMessage][cf_org_name]" => "[cf][org_name]" }
    rename => { "[LogMessage][cf_space_id]" => "[cf][space_id]" }
    rename => { "[LogMessage][cf_space_name]" => "[cf][space_name]" }
    rename => { "[LogMessage][msg]" => "[@message]" }
    rename => { "[LogMessage][event_type]" => "@type" }
    rename => { "[LogMessage][level]" => "@level" }
  }

  mutate {
    uppercase => [ "@level" ]
  }

  date {
    match => [ "[LogMessage][time]", "ISO8601"]
    target => "@timestamp"
  }

  # Capture nanoseconds as @timestamp_ns from UNIX timestamps with nanosecond precision - eg, from 1458655387.327962286 store @timestamp_ns=962286
  ruby {
    code => 'event["@timestamp_ns"] = "#{event["LogMessage"]["timestamp"]}".slice(-6,6).to_i '
  }

  mutate {
    convert => { "[@source][index]" => "integer" }
    remove_field => [
      "[LogMessage][origin]",
      "[LogMessage][cf_origin]",
      "[LogMessage][time]",
      "[LogMessage][timestamp]"
    ]
    add_tag => ["LogMessage"]
  }
}
